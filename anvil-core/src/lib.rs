use crate::anvil_api::auth_service_server::AuthServiceServer;
use crate::anvil_api::bucket_service_server::BucketServiceServer;
use crate::anvil_api::internal_anvil_service_server::InternalAnvilServiceServer;
use crate::anvil_api::hugging_face_key_service_server::HuggingFaceKeyServiceServer;
use crate::anvil_api::hf_ingestion_service_server::HfIngestionServiceServer;
use crate::anvil_api::object_service_server::ObjectServiceServer;
use crate::auth::JwtManager;
use crate::config::Config;
use anyhow::Result;
use cluster::ClusterState;
use deadpool_postgres::{ManagerConfig, Pool, RecyclingMethod};
use std::collections::HashMap;
use std::str::FromStr;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio_postgres::NoTls;
use tracing::{error, info};

// The modules we've created
pub mod auth;
pub mod bucket_manager;
pub mod cluster;
pub mod config;
pub mod crypto;
pub mod discovery;
pub mod middleware;
pub mod object_manager;
pub mod persistence;
pub mod placement;
pub mod s3_auth;
pub mod s3_gateway;
pub mod services;
pub mod sharding;
pub mod storage;
pub mod tasks;
pub mod validation;
pub mod worker;

// The gRPC code generated by tonic-build
pub mod anvil_api {
    tonic::include_proto!("anvil");
}



// Our application state, which will hold the persistence layer, storage engine, etc.
#[derive(Clone)]
pub struct AppState {
    pub db: persistence::Persistence,
    pub storage: storage::Storage,
    pub cluster: ClusterState,
    pub sharder: sharding::ShardManager,
    pub placer: placement::PlacementManager,
    pub jwt_manager: Arc<JwtManager>,
    pub region: String,
    pub bucket_manager: bucket_manager::BucketManager,
    pub object_manager: object_manager::ObjectManager,
    pub config: Arc<Config>,
}

impl AppState {
    pub async fn new(global_pool: Pool, regional_pool: Pool, config: Config) -> Result<Self> {
        let arc_config = Arc::new(config);
        let jwt_manager = Arc::new(JwtManager::new(arc_config.jwt_secret.clone()));
        let storage = storage::Storage::new().await?;
        let cluster_state = Arc::new(RwLock::new(HashMap::new()));
        let db = persistence::Persistence::new(global_pool, regional_pool);
        let sharder = sharding::ShardManager::new();
        let placer = placement::PlacementManager::default();

        let bucket_manager = bucket_manager::BucketManager::new(db.clone());
        let object_manager = object_manager::ObjectManager::new(
            db.clone(),
            placer.clone(),
            cluster_state.clone(),
            sharder.clone(),
            storage.clone(),
            arc_config.region.clone(),
            jwt_manager.clone(),
            arc_config.anvil_secret_encryption_key.clone(),
        );

        Ok(Self {
            db,
            storage,
            cluster: cluster_state,
            sharder,
            placer,
            jwt_manager,
            region: arc_config.region.clone(),
            bucket_manager,
            object_manager,
            config: arc_config,
        })
    }
}


